# [现代处理器性能分析及优化(简述)](https://github.com/Jared-ZDC/Jared-ZDC.github.io/issues/3)

一直以来，工程师都有一个观念：“性能为王”，以前是，现在是，以后更是。

根据[《Data Never Sleeps 5.0》](https://www.domo.com/learn/data-neversleeps-5?aid=ogsm072517_1&sf100871281=1)调查研究，世界上每天产生2.5万亿字节的数据，并且保持着每年25%的速度递增。在我们如今的社会生活中，信息产生的来源越来越多，信息交换的速度越来越快，推动了对更快软件（SW）和更快硬件（HW）的需求。简而言之，数据增长不仅对计算能力提出了更高的需求，而且对存储和网络系统也提出了更高需求。

在PC时代，开发人员通常直接在操作系统之上编程，有时候还不可避免的需要控制软件跟硬件的协调情况。随着世界进入云时代，软件堆栈变得更深更复杂。通过对底层硬件的高度抽象，大多数开发人员往往无需对于实际硬件的把控，直接基于分布式、虚拟化、微服务以及更高层次的开发环境进行开发，效率极大提高的同时，却也带来了消极的一面，现代应用程序对于硬件的亲和性逐渐降低。

当然这也幸亏于摩尔定律的有效性，软件程序员几十年来一直“轻松愉快”。过去，一些软件供应商更愿意等待新一代硬件来加快应用程序的速度，而不花费人力资源来改进代码。但是，花无百日红，在如今摩尔定律正在逐渐失效，通过查看图1，我们可以看到单线程性能增长正在放缓，想要再通过简单的ScalUp的方式提高性能，收益越来越小。

![Figure 1: 40 Years of Microprocessor Trend Data. © Image by K. Rupp via karlrupp.net](https://user-images.githubusercontent.com/17999499/160777801-b618dc94-0548-4ea7-b796-a752302d37e8.png "Figure 1: 40 Years of Microprocessor Trend Data. © Image by K. Rupp via karlrupp.net")

因此当硬件性能提升不再提供显著的收益时，我们必须开始更多地关注代码运行的速度，分析软硬件运行方式，协同能力，并且进行优化。
>“Software today is massively inefficient; it’s become prime time again for software programmers to get really good at optimization.” - Marc Andreessen, the US entrepreneur and investor (a16z Podcast, 2020)

>***个人经验**：在英特尔工作期间，我经常听到这样的故事：当英特尔客户应用程序运行性能不达标时，他们会立即下意识地开始指责英特尔的CPU性能不足。但是，当英特尔派遣我们的性能优化专家与他们合作并帮助他们改进应用程序时，客户的程序性能立刻提高5到10倍*

>***笔者经验**：笔者曾经也处理过类似的案例，在华为鲲鹏处理器上运行的一个加密货币的业务，仅仅因为优化了一下软件的算法指令，性能直接提升20倍以上。由此可见，很多时候，并非处理器性能不达标，而是软硬协同能力不足，并没有充分发挥处理器的能力*

优化应用性能是一件具有挑战性的工作，通常需要大量的努力，但希望这本书能够给你提供一定的帮助！

## 为什么需要性能优化

现代CPU核心数量逐年递增。从2019年底开始，市场上已经有了高达100个核心的处理器（目前估计可以到200个核心以上了），这是非常令人兴奋的，但这并不意味着我们不必再关心性能了，甚至于更多的核心有可能导致应用性能反而出现下降的可能。

一般来说，通用多线程应用程序的性能并不总是随我们分配给任务的CPU核心数量线性扩展。了解发生这种情况的原因以及修复这种情况的可能方法对于产品性能的未来增长至关重要。如果不对应用进行适当的性能分析和调整，这将会导致大量的性能和资金浪费，并扼杀项目产品。

根据paper[《There’s plenty of room at the Top: What will drive computer performance after Moore’s law?》](https://www.science.org/doi/10.1126/science.aam9744)研究表明，至少在短期内，大多数应用程序的性能提升将来自软件栈的优化。但是遗憾的是，应用程序默认条件下很难无法获得最佳性能。该paper还提供了一个很好的示例，说明了在源代码级别上进行性能优化潜力极大。如下表1显示了各种优化方案的性能提升的比例，该测试程序是两个4096×4096矩阵进行相乘，通过应用多种优化手段，最终结果是程序运行速度相较原始程序快了60,000倍以上。提供这个例子的原因并不是为了挑Python或Java（它们是伟大的语言）毛病，而是为了打破软件默认具有“足够好”性能的信念。

<div align=center>
<img alt="Speedups from performance engineering a program that multiplies two 4096-by-4096 matrices running on a dual-socket Intel Xeon E5-2666 v3 system with a total of 60 GB of memory" src="https://user-images.githubusercontent.com/17999499/160841312-ef79eeaa-814a-4660-ad9a-2d5523750095.png" width="400" height="180" title="Speedups from performance engineering a program that multiplies two 4096-by-4096 matrices running on a dual-socket Intel Xeon E5-2666 v3 system with a total of 60 GB of memory"/>
</div>
<div align=center>
<img alt="Speedups from performance engineering a program that multiplies two 4096-by-4096 matrices running on a dual-socket Intel Xeon E5-2666 v3 system with a total of 60 GB of memory" src="https://user-images.githubusercontent.com/17999499/160841447-b8a63538-3a73-4360-944e-bb2bc6aedc91.png" width="400" height="100" title="Speedups from performance engineering a program that multiplies two 4096-by-4096 matrices running on a dual-socket Intel Xeon E5-2666 v3 system with a total of 60 GB of memory"/>
</div>

一般情况下，以下因素会对应用软件的性能造成比较大的影响：
* **CPU限制**，有人可能会问，“为什么处理器不能解决所有的问题？”， 现代CPU的处理速度如此之快，甚至每一代都有一定的提升，但是CPU仍然执行的是人们告诉它的程序，换句话说，程序员给定的程序是什么样的，它就按照什么样执行。比如程序员给定的是冒泡排序，它不会自动的选择更快的快速排序方案。它还是会盲目地执行它被告知要做的任何事情，这就导致了如果程序员给定的一个傻白甜的程序块，CPU也只能傻乎乎的执行，从而影响了整体应用的性能。*有兴趣的同学可以看看这个新闻：[打开游戏要运行 19.8 亿次 if 语句？黑客嘲讽 RockStar 游戏代码太烂了](https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/)*

* **编译器限制**，诚然，如今的编译器越来越智能，可以主动进行非常多的优化，因此很多开发人员也意识不到编译器做的事情，但是尽管如此，在一些涉及到更复杂的决策时，还是无法完美的达到最佳情况。这是由于编译器第一性要求是保证程序的正确性，在一些场景下，由于无法确定程序员的真实意图，编译器也无法激进的进行优化，不得不倾向于更保守的编译选择，因此在某些场景下，编译器也提供了一些特定的指令或选项，让开发人员指定优化方案，已达到更佳的性能。

* **经验算法限制**，开发人员有时候往往痴迷于算法的复杂性，默认觉得O(N log N)的算法一定比O(<img src="https://latex.codecogs.com/svg.latex?N^2" />)性能要强，比如考虑InsertionSort以及QuickSort，大负债工作量下，QuickSort是相对于InsertionSort具有一定的优势，但是假如工作负载较小时，InsertionSort性能反而优于QuickSort。在没有测试目标工作负载的情况下盲目相信 Big O 表示法，可能会导致开发人员走上错误的道路。所以，即使是最知名的算法，对于所有的可能的输入，性能不一定是实践中最高的。

> ***笔者经验：** 在性能优化中，往往这一块经常犯经验性的错误，比如在一个数据库性能优化中，我们往往觉得更快的存储设备性能越佳，但是在特定场景中，NVME盘的性能甚至比不过一个简单的SSD盘的性能*

上述限制为我们的优化软件的性能留下了充足的空间。 从广义上讲，软件堆栈包括许多层，例如，固件、BIOS、操作系统、
库和应用程序的源代码。 但由于大多数较低的 SW 层不是在我们的直接控制下，因此我们优化的主要重点将放在应用可控的源代码上。 另一个重要的点是我们将经常接触的软件是编译器，通过编译器进行优化，获得性能的提升是非常有可能的，在本书中可以找到许多这样的例子。

>* **作者经验：** 即使不是编译器相关的专家也可以通过编译器对应用程序进行优化，并且根据我的经验，至少 90% 的优化可以在源代码级别完成，无需深入研究编译器源代码。 虽然，了解编译器的工作原理以及知道如何让它做你想做的事情在与性能相关的工作中总是有好处的。*

>* **笔者经验：** 在实际优化的项目中，往往分析的第一顺序是应用程序源码本身，其次是编译器，库，操作系统以及更加底层的驱动，硬件优化等等，同时依次优化的难度递增，优化带来的收益相对而言也越小（这个不完全一定，笔者也遇到过硬件的一个配置直接极大的提升了整体软件的性能，比如打开硬件的预取等）。*

此外，由于现代处理器多核多线程的原因，应用程序分布在多核之间并行运行，也会给应用程序带来通信相关的消耗以及资源竞争相关的问题。

值得一提的是，性能提升不仅来自优化软件。根据 paper[《There’s plenty of room at the Top: What will drive computer performance after Moore’s law?》](https://www.science.org/doi/10.1126/science.aam9744)研究表明，算法（特别是对于机器学习等新问题领域）和效率更高的流水线硬件设计。 算法显然在应用程序的性能中起着重要作用，但我们不会在本书中讨论这个主题。 我们也不会讨论新的硬件设计架构，因为大多数时候，软件开发人员更多的是面向当前已有的处理器。但是，了解现代 CPU 设计对于优化应用程序非常重要。

> * **笔者经验：** 在很多CPU公司都需要有懂处理器设计的软件性能优化人员，并且多多益善，笔者曾经在华为为鲲鹏处理器招聘这方面的人才，相对硬件设计来说，既懂软件又懂硬件的人才实在太少了， 大家可以看看如下Intel的招聘要求：

<div align=center>
<img alt="Intel Performance Engineer" src="https://user-images.githubusercontent.com/17999499/160859758-4851e46a-756a-4cec-92ed-9875271461a8.png" width="700" height="200" title="Intel Performance Engineer"/>
</div>

在后摩尔时代，代码优化能力的重要性越来越高，特别是需要根据运行它的硬件进行软硬协同优化，这一点对于工程师的要求也越来越高，也是区分码农与码神的关键因素。

本书中的方法主要是榨干程序的最后一点性能提升空间。通常这类方法的优化提升的空间不大，一般情况下不超过 10%，例如上表1中的第6/7行。但是，不要低估 10% 提升的重要性，它特别适用于在云环境中运行的大型分布式应用程序。根据google研究分析显示，2018年，谷歌在电力和冷却基础设施上的消耗几乎与其购买的一系列服务器的花费相当，而提升软件的性能就能够直接改善能源消耗，带来相应的收益显而易见。

>“At such scale, understanding performance characteristics becomes critical – even small improvements in performance or utilization can translate into immense cost savings.” [Kanev et al., 2015](https://doi.org/10.1145/2872887.2750392)

## 谁需要性能优化
